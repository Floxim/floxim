**Как устроен Флоксим**

Во Флоксиме бывают следующие сущности:
 - контроллер - класс, содержащий набор action-методов, action возвращает результат в виде массива с какими-либо данными.
 - шаблон - то, чем можно отобразить результат работы контроллера.
 - инфоблок - запись в БД, содержащая информацию о том, что на некотором наборе страниц в некоторой области нужно показать результат работы такого-то controller-action'а таким-то шаблоном. То есть инфоблок совокупляет контроллер с шаблоном и привязывает их к набору страниц.
 - модель - классы для работы с данными, содержат бизнес-логику, изолируют БД. Каждая модель соответствует некоторому типу данных и содержит два класса: finder - производит операции над данными (выборка / сохранение / удаление), essence - объектное представление отдельной записи в БД (а-ля ActiveRecord). Finder-ы лежат в /floxim/data/, классы имеют префикс "data" essence'ы лежат в /floxim/essence/, имя класса такое же, как у обрабатываемого типа данных. То есть для модели "site" (таблица fx_site) класс-файндер лежит в /floxim/data/site.php и называется fx_data_site, класс-эссенс лежит в /floxim/essence/site.php и называется fx_site.
 - роутер - класс, получающий на вход HTTP-запрос, и возвращающий подходящий контроллер, либо null, если запрос не подходит для этого роутера.

Флоксим обрабатывает запрос следующим образом.

1. Все запросы через mod_rewrite уходят на /index.php
2. В boot.php загружается конфиг и автолодер.
3. Файл /floxim/index.php запускает роутинг. Запрос обрабатывается цепочкой роутеров, пока какой-нибудь не вернет контроллер или готовый результат. Сами роутеры живут во /floxim/routing/. Запросы к сайту обслуживает router_front.php, к админке - router_admin.php, есть еще роутеры для 404 ошибки, для аяксовой загрузки отдельных блоков и т.д.
4. Для страниц сайта роутинг возвращает контроллер-инфоблок, соответствующий всей странице. Контроллер-инфоблок - это такой контроллер, который умеет собирать инфоблок, то есть на вход принимает ID инфоблока и страницу-контекст, на выходе возвращает результат работы контроллера, привязанного к этому инфоблоку, обработанный шаблоном, привязанным к этому же инфоблоку. 
5. К инфоблоку, который собирается на предыдущем шаге, привязан контроллер "layout" с экшном "show" - этот контроллер достает все инфоблоки, которые должны быть показаны на этой конкретной странице, а также информацию о самой странице. Его шаблон - шаблон-лейаут, то есть вся обвязка сайта. В обвязке определяются области (area), где могут быть показаны инфоблоки.
6. При отработке шаблона-лейаута для каждой области собираются инфоблоки, назначенные в нее (то есть выполняется контроллер/экшн, привязанный к инфоблоку, затем на его результат накладывается шаблон, привязанный к инфоблоку), результат вставляется в область.

**Компоненты**

Компонент - составная структура для работы с контентными данными. Компонент определяет тип контента, например "Новости" - задает название типа и информацию обо всех его полях (описание таблички в БД). Данные компонентов хранятся в табличках с префиксом "content", например "fx_content_news". Для компонента есть базовый контроллер, от которого могут наследоваться другие контроллеры компонентов (например мы можем создать fx_controller_component_news extends fx_controller_component). В базовом компонент-контроллере определен набор типичных методов-экшнов: list_infoblock для отображения списка данных компонента, привязанных к разделу, list_filtered - для отображения произвольного списка (например, транслирует данные в другой раздел), record - для отображения отдельного объекта.

Компоненты могут наследоваться на уровне модели. Например, для "новости" получится примерно такая цепочка:
 - fx_content - записи вообще для всего контента, там хранится тип, родитель, системные поля типа "кто и когда создал".
 - fx_content_page - наследуется от fx_content, определяет поля, характерные для любой страницы: URL, title, keywords и т.д.
 - fx_content_news - добавляет поля, характерные для новости: видимая дата публикации, анонс и т.д.

Поскольку компонент-наследник имеет все поля компонента-родителя, мы можем наследовать их шаблоны. То есть мы можем показывать "новости" любым шаблоном, определенным для "страниц".

Кроме того, реализовано псевдо-наследование шаблонов для экшнов: если шаблон объявлен как подходящий для "component_page.list", им можно отобразить результат работы любого экшна, начинающегося с "list" - list_filtered, list_top, list_by_author и т.д.

Для компонентов не обязательно создавать классы моделей и контроллера. Если какой-то из классов отсутствует, будет использован ближайший (по цепочке наследования) существующий.

**Как что делать**

Для наиболее частых операций есть "класс-шорткат" fx, содержащий статические методы. Вот некоторые примеры.

**fx::data()**

Возвращает данные, либо finder для данных.

        $com = fx::data('component', 10); // получить компонент с id=10

Finder умеет строить запросы через chained-вызовы:

        $com = fx::data('component')->where('keyword', 'news')->one(); // получить компонент с keyword='news'
        $com = fx::data('content_news')->
           where('author_id', 10)->
           order('publish_date','desc')->
           limit(5)->
           all(); // получить 5 последних новостей автора #10.

Finder может создавать записи:

        $news = fx::data('content_news')->create(array('title' => 'Super news'));
        $news->save();

**fx::controller()**

Возвращает контроллер, загруженный параметрами.

        $ctr = fx::controller('component_news.listing', array('parent_id' =>10));
        $res = $ctr->process(); // массив с результатом

**fx::template()**

Загружает шаблон

        $tpl = fx::template('component_news.list');
        echo $tpl->render($res); // $res из предыдущего примера

**fx::db()**

Возвращает экземпляр класса-абстракции БД (основан на PDO)
Названия таблиц следует указывать без префикса fx, и заворачивать в двойные фигурные скобки:

        $news = fx::db()->get_results('select * from {{content_news}}');
        fx::db()->query('update {{content_news}} set title = 'olo' where id = 2');

**fx::is_admin()**

Сообщает, является ли текущий юзер админом

**fx::env()**

Возвращает объект с "окружением" - туда записываются текущий сайт, текущая страница, текущий выбранный шаблон, текущий юзер и т.д.

**fx_collection**

Классы-файндеры возвращают объекты fx_collection, наша обертка над стандартными массивами. Умеют следующее:

        $news = fx::data('content_news')->all(); // $news - fx_collection
        foreach ($news as $news_item) { ... } // можно обходить как обычный массив
        $news_ids = $news->get_values('id'); // вернет массив с идентификаторами
        $my_news = $news->find('author_id', 10); // вернет коллекцию новостей, у которых author_id=10
        $the_news = $news->find_one('id', 100); // вернет первую найденную
        $news->find_remove('author_id', 10); // удалит из коллекции все новости с автора #10
        // можно группировать
        // вернет коллекцию коллекций для каждого родителя
        // аргумент - функция, которая получает элемент коллекции и возвращает ключ для группировки
        $by_parent = $news->group( function($news) {
            return $news['parent_id'];
        });
        echo "News in  ".count($by_parent)." sections";

**essence**

Объект-эссенс можно использовать так:

        $news = fx::data('content_news', 10); // получили новость с id=10, это экземпляр fx_content_news
        echo $news['title']; // доступ к полям  - через ключи массива
        $news['title'] = 'OLOLO'; // изменение - тоже
        
        echo $news->get('anounce'); // есть дублирующие методы get()
        $news->set('anounce', 'Trololo'); // и set()
        // благодаря ним можно писать так:
        echo fx::data('content_news', 12)->get('name');
        
        $news->save(); // сохранили изменения
        $news->delete(); // удалили новость

В essence-классе можно определить специальные методы для сохранения целостности: _before_save(), _before_update(), _after_update(), _before_insert(), _after_insert(), _before_delete(), _after_delete().

Система поддерживает поля-связи: HAS_ONE, HAS_MANY, MANY_MANY.
Чтобы извлечь записи вместе со связанными объектами, используется метод файндера with().

        // HAS_ONE
        $news = fx::data('content_news')->with('author')->where('id', 12)->one();
        echo $news['author']['name']; // в $news['author'] - эссенс с автором
        
        // HAS_MANY
        $authors = fx::data('content_user')->with('news')->all();
        foreach ($authors as $author) {
           echo $author['name'].' has '.count($author['news']).' news, ';
           echo 'first is '.$author['news']->first()->get('name')."<br />";
        }
        
        // MANY_MANY
        // посты и теги связываются через третий компонент "tagpost"
        // но эту инфу можно скрыть :)
        $post = fx::data('content_blogpost')->with('tags')->where('id', 12)->one();
        echo "Post ".$post['name']." has tags: ".join(', ', $post['tags']->get_values('name'));

**Отладка**

Есть небольшая утилитка для отладки - дампит любые переменные в лог. Использовать так:

        fx::log($var1, $var2, 'ololo');

После этого смотрим результаты в админке - "Development - logs" - видим список лог-файлов, метод, URL и время создания. Щелкаем нужный - видим результат. Объекты-массивы сворачиваются для удобства восприятия. Любые переменные можно вывести на экран в таком же виде прямо из скрипта, написав:

       fx::debug($var1, $var2);
       
Запись в лог удобно использовать, чтобы не ломать сайт, а вывод через fx::debug - в маленьких скриптах-тестах. 
